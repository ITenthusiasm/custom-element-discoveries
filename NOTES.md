# Notes

- [`Element.getAttributeNames()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames) -- when used in conjunction with [`Element.getAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute) -- is allegedly more performant than [`Element.attributes`](https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes).
  - MDN's docs/notes on [live HTML collections](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection) might prove insightful here.
- Based on MDN's notes about [`DocumentOrShadowRoot.activeElement`](https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement) and [`Document.hasFocus()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/hasFocus), it seems like `document.activeElement` is only guaranteed to be `:focus`ed _if_ said element is in a `Document` satisfying `Document.hasFocus() === true`. This is worth remembering. That said, in some cases (as in some of our `combobox` logic), it is sufficient to just check `document.activeElement` to achieve the desired behavior. What you need to do depends on your use case.

## `ComboboxField` + `listbox`

- **Screen Readers and `[role="option"][inert]`**: It seems that if the only child in a `listbox` is a `[role="option"][inert]` HTMLElement, then Screen Readers (or at least VoiceOver) will view the `listbox` as empty. This is a big deal because it's important to have _some_ kind of indicator that no `option`s match the user's current filter. Showing a blank screen (i.e., showing no menu when no `option`s match the filter) could work, but that may not be as clear. Between `Mantine`, `Shadcn UI`, `Reach UI`, `React Select`, and `Vue Select`, Mantine is the only Component Library that doesn't have a "No Options" display. If we can meet accessibility requirements **_and_** make things clearer for visual users, we should definitely do **_both_**.
- You should prefer private `static` methods for event handlers whenever possible. However, if you **_need_** access to `this`, then just use a private arrow function. Certainly, if you can find a way to _avoid_ using `this` so that you can keep a method as `static`, then do so. However, you should do this reasonably. For example, it is _unreasonable_ to expose a copy of a private field (`get matchingOptions() { return this.#matchingOptions.slice() }`) strictly for the sake of being able to use a `static` method for an event handler. Not only does this waste memory at runtime, but it runs the risk of introducing confusion and unforeseen bugs. Keep things simple and just use an arrow function if you need to; it shouldn't harm your end users.
  - As a side note, for this very reason, **_you should avoid using `this` as much as possible (within reason)_**. It's theoretically possible that in the future, a refactor would make itself known which would enable you convert your instance arrow function back to a `static` method. Those opportunities will become more obvious if you, for example, reach for a `combobox` via `event.target` instead of through `this`.
- Currently, our `combobox` component displays a "No Options" message (which is an `inert`, fake `option`) if the user's filter doesn't match any of the component's options. (This is only in `filter` mode, obviously.) This message is modifiable, but some people may not want to display a message at all. In that case, they can simply use CSS to hide the `listbox` if it doesn't contain any `option`s which aren't [`data-filtered-out`]; there are no code changes that need to be made on our side. But this is at least worth documenting when we write the overall documentation for this component.

## DOM / JavaScript

- Apparently, the `focus` event triggers after the `mousedown` event but before the `mouseup` event, which triggers immediately before the `click` event. We were able to use this knowledge to differentiate between `:focus`ing that was initiated by clicking vs. tabbing in our code.
- If a `Range` points to content inside a [`Text`](https://developer.mozilla.org/en-US/docs/Web/API/Text) Node (which is itself [`CharacterData`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData), which seems to have many helpful methods), then using [`CharacterData.insertData()`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/insertData) **_will not_** reset the `Range` offsets to the beginning of the Node (unlike changing the [`Node.nodeValue`](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue) directly with something like `textNode.nodeValue = MY_STRING`).
- [According to the Spec](https://dom.spec.whatwg.org/#dom-node-textcontent), an element's child nodes will be _completely_ removed when the [`Element.textContent`](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) setter is called. If the setter is called with an empty string (or anything that is _mapped_ to an empty string), then the element will be left empty. (This seems similar to how `Element.innerHTML` behaves when given an empty string.) If the setter is called with a regular string, then a new `Text` node is created and inserted as the the element's only child.
  - We'll need to be mindful of this in the codebase. If we expect a component to _always_ have a text node (as is the assumption for the `<combobox-field>`), then we'll need to avoid using `Element.textContent = ""`. Instead, we'll need to leverage `Text.nodeValue = ""` or another similarly-safe approach (like [`CharacterData.data = ""`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/data)).
  - This piece of information is also important when it comes to modifying `Range`s, as deleting/replacing the reference to an element's original `Text` node can lead to unexpected/broken behavior when trying to work with `Range`s that point to the element's contents.
- For some odd reason, in `Chrome` and `Firefox`, the UserAgent (UA) would try to focus the `listbox` in the `<select-enhancer>` whenever `Tab` was pressed if the `combobox` was expanded. This happened both while `Tab`bing forwards and backwards. The behavior is most easily replicated if you force the `combobox` to be expanded with `setAttribute` and then try moving focus with `Tab`. (Safari did not exhibit this awful and confusing behavior.) This caused unexpected bugs in the code, so now we have to place a `[tabindex="-1"]` attribute on the `listbox` element.
- [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Attributes/disabled) form controls that are [`contenteditable`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/contenteditable) behave differently across different browsers. Consider `<button disabled contenteditable="true">Content</button>` in each of the 3 Major Browsers:
  - **Chrome** (137): Prevents focusing via Keyboard Navigation (`Tab`bing), Clicking, and `HTMLElement.focus()`. This is the ideal behavior.
  - **Safari** (18.5): Prevents focusing via Keyboard Navigation (`Tab`bing) and `HTMLElement.focus()`. However, if the element is clicked, it receives a cursor and can still be modified.
  - **Firefox** (140): Does not prevent **_ANY_** of the 3 aforementioned means of focusing an element. To Firefox, if the element is `contenteditable`, it's focusable.
  - Due to these discrepancies, if you want a `[contenteditable]` form control _not_ to be interactive when `disabled`, then you'll have to toggle `[contenteditable]` between `"false"` and `"true"` yourself.

## `Ranges`, `Selection`, and Reimplementing the `input` Event

- Useful links/docs:
  - https://javascript.info/selection-range
  - https://developer.mozilla.org/en-US/docs/Web/API/Range
  - https://developer.mozilla.org/en-US/docs/Web/API/Selection
- Firefox is the only Browser that supports multi-selection. We could skip supporting it, but we'll choose to support it to avoid breaking user expectations. Note that when Firefox encounters a multi-select for an `<input>` element, it will place the selection at the very end of the _last_ selection range when text is inserted into the form control. (You should TEST that you're satisfying this behavior.)
- Unlike `Chrome` and `Firefox`, in `Safari` you cannot use [`Selection.addRange()`](https://developer.mozilla.org/en-US/docs/Web/API/Selection/addRange) to set the `Document`'s current selection to something WITHIN a `Shadow DOM`. However, you CAN use [`Selection.setBaseAndExtent()`](https://developer.mozilla.org/en-US/docs/Web/API/Selection/setBaseAndExtent) for this. Note that Chrome/Firefox support `Selection.addRange()` if the `Range` has "legal" access to content in a `Shadow DOM`. However, since we're trying to create something with cross-browser support, this is irrelevant. Some helpful resources:
  - Some hiccups people have run into when trying to get Selections in the Shadow DOM: https://stackoverflow.com/questions/62054839/shadowroot-getselection/70523247#70523247
  - What seems to be some discussion on the new expectations/hopes for how `Selection` will behave in the Shadow DOM: https://github.com/mfreed7/shadow-dom-selection?tab=readme-ov-file#changes-to-existing-selection-apis. (This may not technically be the official spec, but it seems to be the direction in which things are moving so far.)
- Apparently, all (non-static) `Range`s previously associated with a `Text` Node get emptied once the referenced node's `nodeValue` is re-set with `set Node.nodeValue()`. (The `Range`s probably don't know what to point to anymore since the underlying value of the `Node` has technically changed.) This makes it imperative that you know when to leverage the a `StaticRange` and when to work directly with a regular, dynamic `Range` (or a value that it cached before being modified).
  - Alternatively, you can just leverage the `CharacterData` methods, like `insertData()` and `deleteData()`. These methods will _preserve_ the `Range` information of the `Text` node that you're modifying (as much as possible) -- even if some of the `Range`'s contents are deleted by `deleteData()`. Why worry about what `set Node.nodeValue()` will do and how you should cache your `Range` data when you can just use the `CharacterData` methods to help you avoid worrying about such things?
- By default, browsers will collapse multiple occurrences of whitespace between character strings. So if you have a `<div contenteditable="true">` and you execute `div.textContent = "Hello" + " ".repeat(5) + "World"`, then the browser will display what _looks_ like `"Hello World"` even though `get div.textContent()` will return a string with the appropriate number of spaces. To force the browser to display _all_ whitespace instead of collapsing it, you need to use the [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space) CSS property. (You can also try [`white-space-collapse`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse), but broad and stable support for the `preserve-spaces` value is missing.)
  - If you're wondering how users can insert multiple spaces into `[contenteditable]` elements, it's because the browser inserts HTML into the `[contenteditable]` element instead of pure white space. In other words, the browser will insert something like `Hello&nbsp; &nbsp; &nbsp;World` instead of using empty strings only. However, this behavior is not always desirable. We concluded that this behavior wasn't viable for our `ComboboxField` since we're accepting and manipulating Plaintext only instead of HTML. (That is, we use `"text/plain"` in `DataTransfer.getData()` instead of `"text/html"`.) So we intentionally used pure white spaces when re-implementing the `input` event. (Indeed, I think we were _forced_ to.) Consequently, we recommend users update the `white-space` CSS property of the `<combobox-field>` as needed.
- The `[contenteditable="plaintextonly"]` attribute setting seems to behave inconsistently between Browsers. For this reason, it's best to just stick to `[contenteditable="true"]` for now, even though it doesn't represent what we're truly looking for. Here are some things we found:
  - Safari + Firefox: When `[contenteditable="plaintextonly"]`, the `beforeinput` event will still show `text/html` data in the `InputEvent.dataTransfer.types` even though such information is arguably irrelevant, and `InputEvent.getTargetRanges()` will return the correct information. Additionally, `InputEvent.data` will be `null`.
  - Chrome: When `[contenteditable="plaintextonly"]`, the `text/html` data will not be exposed by the `InputEvent`. In fact, `InputEvent.dataTransfer` will be `null`! And the developer will have to check `InputEvent.data` instead. This makes some sense. However, Chrome also excludes the `InputEvent.getTargetRanges()` data in this scenario, making it difficult (if not impossible) to reasonably re-implement the `input` event's behavior fully.
  - Due to these inconsistencies (especially when it comes to `dataTransfer` vs `data`), it's best to just stick to `[contenteditable="true"]` since doing so will result in consistent behavior across browsers, in addition to guaranteeing that we'll always have access to the correct Target Ranges.
  - It's currently unclear whether we should file a Chromium Bug for this right now since it isn't clear which browser has the "correct" behavior. Both implementations have some downsides to them.
- It seems that when you're inserting text into an empty element, the `StaticRange` returned from `beforeinput` points to the element itself instead of the empty `Text` node that the element holds (assuming element contains a `Text` node). When you're leveraging the `StaticRange`s returned from `InputEvent.getTargetRanges()`, you need to take this into account. If you can force circumstances that allow you to make valid assumptions, then you can work conveniently with those assumptions.
  - For example, if you can guarantee that the target element will always have a single `Text` node and nothing else, then you can just opearte directly on that `Text` node instead of referencing `StaticRange.startContainer`.
  - Otherwise, you'll need to bring about whatever circumstances that you require. For example, if you _need_ the target element to have a `Text` node, then you can check the element returned from `StaticRange.startContainer` for a single `Text` node child. If one exists, you can operate on it. If one doesn't exist, you can insert a new `Text` node into the element and then operate on that text node.
- It seems to be safe to remove `\r`s and `\n`s from an `InputEvent`'s data before interacting with the `StaticRange`s from `getTargetRanges()`. This is because newlines are represented by newly-created `HTMLElement`s, which themselves become `contenteditable` (because of the owning/wrapping `contenteditable` element) and have the ability to receive `beforeinput` events which bubble up to the owning element that listens for all `beforeinput` events. This paradigm makes it unnecessary for the `StaticRange`s to take newlines into account in their `offset`s, so characters like `\r` and `\n` don't influence the `offset`s at all. Therefore, it is perfectly safe (from what we can tell from our brief testing in Firefox) to delete all `\r`s and `\n`s from a string before interacting with the `StaticRange`s.

## Testing

- [Playwright's approach to its `ControlOrMeta` key](https://github.com/microsoft/playwright/blob/8e4627826a6bacdc97582e53ee34a1db4a9647e7/packages/playwright-core/src/server/input.ts#L153-L157) (search for `ControlOrMeta` or for `resolveSmartModifierString`) involves leveraging [`process.platform`](https://nodejs.org/api/process.html#processplatform).
- Apparently, MacOS doesn't allow tabbing to controls like `<button>`s by default. Because of this, if you run Playwright against a Safari (WebKit) browser on MacOS, all tests expecting `<button>`s (or other similar controls) to be focused via `Tab` navigation will fail. (Note: This is not an issue for all controls. For instance, `textbox`es work just fine.) This is why your Safari tests may work on a Linux Machine in CI, but not locally on your MacOS machine. The solution to this problem is to enable tabbing into controls on your local MacOS.
  - Enabling this in Safari > Settings > Advanced > "Press Tab to highlight each item on a webpage" **_will not_** work. It will work for your local Safari version, but **_not_** for your Playwright Tests.
  - Instead, visit System Settings > Keyboard > Keyboard Navigation. The subtext for this option says something like:
    > Use keyboard navigation to move focus between controls. Press the Tab key to move focus forward and Shift Tab to move focus backward.
    - Toggle "Keyboard Navigation" on by clicking its toggle switch. Now your Playwright test(s) should be passing.
  - See [Stack Overflow](https://stackoverflow.com/questions/67901731/cannot-focus-button-using-tab-key-navigation-on-safari/67901876#67901876) for additional details.
- In `@playwright/test@1.54.1`, the [`Locator.fill()`](https://playwright.dev/docs/api/class-locator#locator-fill) method does not work in Firefox when used on a `[contenteditable]` element whose text content and cursor location are modified by a `beforeinput` event. (See [microsoft/playwright#36715](https://github.com/microsoft/playwright/issues/36715) and [Playwright Issue Firefox Fill](https://github.com/ITenthusiasm/playwright-issue-firefox-fill).) In such a scenario, Playwright will duplicate the provided text when running against Firefox. This issue does not happen during manual testing, nor does it happen if Playwright is run against Chrome or Safari. (We discovered this bug on a MacOS machine. Not sure how other machines behave.) Moreover, this issue does not occur when using [`Locator.press()`](https://playwright.dev/docs/api/class-locator#locator-press) or [`Page.keyboard.press()`](https://playwright.dev/docs/api/class-keyboard#keyboard-press). It's not clear why the `Locator.fill()` bug exists; but for now, if it becomes a problem, you can circumvent the issue by sticking to Keyboard Pressing instead of Locator Filling. Doing so is just as reliable (if not more reliable), but it's slightly less convenient.
