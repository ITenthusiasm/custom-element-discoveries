# Notes

- [`Element.getAttributeNames()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames) -- when used in conjunction with [`Element.getAttribute()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute) -- is allegedly more performant than [`Element.attributes`](https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes).
  - MDN's docs/notes on [live HTML collections](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection) might prove insightful here.
- Based on MDN's notes about [`DocumentOrShadowRoot.activeElement`](https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement) and [`Document.hasFocus()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/hasFocus), it seems like `document.activeElement` is only guaranteed to be `:focus`ed _if_ said element is in a `Document` satisfying `Document.hasFocus() === true`. This is worth remembering. That said, in some cases (as in some of our `combobox` logic), it is sufficient to just check `document.activeElement` to achieve the desired behavior. What you need to do depends on your use case.

## `ComboboxField` + `listbox`

- **Screen Readers and `[role="option"][inert]`**: It seems that if the only child in a `listbox` is a `[role="option"][inert]` HTMLElement, then Screen Readers (or at least VoiceOver) will view the `listbox` as empty. This is a big deal because it's important to have _some_ kind of indicator that no `option`s match the user's current filter. Showing a blank screen (i.e., showing no menu when no `option`s match the filter) could work, but that may not be as clear. Between `Mantine`, `Shadcn UI`, `Reach UI`, `React Select`, and `Vue Select`, Mantine is the only Component Library that doesn't have a "No Options" display. If we can meet accessibility requirements **_and_** make things clearer for visual users, we should definitely do **_both_**.
- You should prefer private `static` methods for event handlers whenever possible. However, if you **_need_** access to `this`, then just use a private arrow function. Certainly, if you can find a way to _avoid_ using `this` so that you can keep a method as `static`, then do so. However, you should do this reasonably. For example, it is _unreasonable_ to expose a copy of a private field (`get matchingOptions() { return this.#matchingOptions.slice() }`) strictly for the sake of being able to use a `static` method for an event handler. Not only does this waste memory at runtime, but it runs the risk of introducing confusion and unforeseen bugs. Keep things simple and just use an arrow function if you need to; it shouldn't harm your end users.
  - As a side note, for this very reason, **_you should avoid using `this` as much as possible (within reason)_**. It's theoretically possible that in the future, a refactor would make itself known which would enable you convert your instance arrow function back to a `static` method. Those opportunities will become more obvious if you, for example, reach for a `combobox` via `event.target` instead of through `this`.
- Currently, our `combobox` component displays a "No Options" message (which is an `inert`, fake `option`) if the user's filter doesn't match any of the component's options. (This is only in `filter` mode, obviously.) This message is modifiable, but some people may not want to display a message at all. In that case, they can simply use CSS to hide the `listbox` if it doesn't contain any `option`s which aren't [`data-filtered-out`]; there are no code changes that need to be made on our side. But this is at least worth documenting when we write the overall documentation for this component.

## DOM / JavaScript

- Apparently, the `focus` event triggers after the `mousedown` event but before the `mouseup` event, which triggers immediately before the `click` event. We were able to use this knowledge to differentiate between `:focus`ing that was initiated by clicking vs. tabbing in our code.
- If a `Range` points to content inside a [`Text`](https://developer.mozilla.org/en-US/docs/Web/API/Text) Node (which is itself [`CharacterData`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData), which seems to have many helpful methods), then using [`CharacterData.insertData()`](https://developer.mozilla.org/en-US/docs/Web/API/CharacterData/insertData) **_will not_** reset the `Range` offsets to the beginning of the Node (unlike changing the [`Node.nodeValue`](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue) directly with something like `textNode.nodeValue = MY_STRING`).
