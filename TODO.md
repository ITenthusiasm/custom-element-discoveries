# TODO

- [ ] When do we want to consider a `searchable` Combobox -- if ever? Should it be its own component? Or should the `ComboboxField` simply be configurable?
  - [ ] **IMPORTANT**: Do we need to remove/reset all `data-filtered-out` attributes once a value is selected (or the `combobox` is otherwise collapsed?)
  - [ ] Document why we always attach `handleSearch` as a listener, and right at the beginning. (Wanting to make sure we can call `event.stopImmediatePropagation` in time.)
  - [ ] If deemed necessary, document why we went with an attribute like `filter`/`search` instead of using a standardized attribute (like `aria-autocomplete`) directly. (We don't know if we'll support the other variant of `aria-autocomplete` yet. It's too weird/complicated/confusing for consumers and maybe even maintainers to have a mount-only attribute that triggers another attribute which triggers another attribute (`filter` --> `aria-autocomplete` --> `contenteditable`). If we want to support other versions of `aria-autocomplete` in the future, we can just update the "universally owning attribute" (e.g., `filter` --> `filter-type`). `filter` is arguably part of the API, where as the other 2 attributes are implementation details. (We could technically just use `ElementInternals.MyAriaAttribute`.) We don't want to mess up the JS-free `<select>` instance by encouraging users to use standardized props like `autocomplete` either.)
  - Document why we will use `<input>`/`<div>` instead of modifying text directly inside `<combobox-field>`. (Basically, Shadow DOM support for `Range`s and `Selection`s is sketchy across browsers, sadly. So it's safer to just use an `<input>` that's in a Shadow DOM. If our suggestion gets accepted, then we'll have an advantage with this change in the future anyway... Actually, we went back to using a `contenteditable` `<combobox-field>` because we concluded that both the filterable and non-filterable versions of our component should have a consistent UX to avoid confusion. So we don't need an easy way to move the cursor around. HOWEVER, we later realized that `contenteditable="plaintext-only"` elements can still include newline characters! They're basically `<textarea>`s! That's HUGE no-no for us. And it's fare more complicated to try to combat that than it is to use a regular `<input>` which doesn't support newline characters. So now we're back to using `<input>`/`<div>`. We don't like the idea of switching element types as the `filter` attribute is updated, but we don't have a choice. We played with having an `input[readonly]` so that we didn't have to switch elements, but it seems to risk confusing Screen Readers, and it sounds like [some browsers apply default styles](https://adrianroselli.com/2024/11/avoid-read-only-controls.html#Styles). Unfortunately... if we go this route... we'll have to figure out transfering attributes appropriately onmount... there might be a way that isn't complicated?)
    - Note: Before you go crazy and think about trying to use `beforeinput` so that we can still stick to modifying the text content of the `<combobox-field>` during "Filter Mode", note that taking this approach (storing the previous value from `beforeinput`, then restoring the previous value if the `input` event reports that the text content includes newline character(s)) will aggressively move the input cursor to the beginning of the text field (though only during value restoration to remove newlines). This is a bad UX on top of a weird maintenance decision. Just use the correct `HTMLElement` (`<input>`) for the job of searching and stop debating this topic.
- [ ] Do we want to add/support a Caret Icon for the Combobox component?
- [ ] Add CSS for `select-enhancer > select` (for when JS is disabled/unavailable).
- [ ] Make a note about using different kinds of Combobox "Adapters"/"Wrappers".
- [ ] Make a note that the `value` of `<combobox-option>` (and therefore a `<select>`'s `<option>`) MUST be unique (for accessibility reasons related to `aria-activedescendant` and HTML's disallowing of duplicate `id`s). This shouldn't realistically cause problems for anyone. I don't know if duplicate values have a valid use case anyway. Duplicate values will produce unpredictable behavior.
- [ ] Add documentation in general about how this component works, what expectations are, and what feature parity is with native `<select>`
  - [ ] **_DEFINITELY_** don't forget to document how delegated event listeners for `input` will get a little wild. (Regular delegated event listeners should be fine. But for captured event listeners, people will have to check things like `!event.isTrusted` or something similar which would indicate that the event actually originated from `<combobox-field>` instead of `<input>`.)
- [ ] Should our tests assume that our Combobox Component is in a `<form>` by default since the custom element itself is a Form Control?
- [ ] We should definitely add a test **_proving_** that our component works in Shadow DOMs at some future point.
- [ ] Consider adding a GitHub CI Action to lint our code.
- [ ] Unless we're mistaken, Playwright currently has a bug. For some reason, the tests related to `tab`bing are failing for Playwright's `WebKit` browser. However, tabbing works fine manually in Safari. Since it works manually, we can investigate this more later or open a Playwright bug. (It's probably a Playwright bug since we didn't actually change any of our code surrounding focusing/tabbing -- unless this is an Operating System issue.) **_NOTE_**: For right now, the tests still seem to be passing on CI. So this really seems to be a Playwright issue and/or an OS issue (or some other similar, inconspicuous issue).

## Potential Considerations

- [ ] Don't the native `<option>` elements allow safe attribute/property changes even if they aren't connected to the DOM? Should we allow something similar? (Mainly thinking of supporting changing the `ComboboxOption.selected` property in isolation.) For example, maybe we could support this by returning early based on `!this.combobox`? Need to investigate... and evaluate if this is even worthwhile...
- [ ] Far-off thought: Should we give developers an easy way to set this component up themselves? We'd also want to make sure that frameworks can create our Web Component just fine, without running into any problems. (There would only be a concern if people wanted to provide `<combobox-option>` and `<combobox-field>` directly instead of using `<select-enhancer>` in conjunction with `<select>` -- at least, that's our assumption). **Note**: This ties into our idea about "Adapters", and it might be sufficient to delegate this problem to UserLand with the "Adapters" concept.

## IMMEDIATE CURRENT WORK/PRIORITY

Double check our existing code to make sure it is [sufficiently] coherent and not absolute garbage **_before_** you go adding new features (like the `formResetCallback` support).
