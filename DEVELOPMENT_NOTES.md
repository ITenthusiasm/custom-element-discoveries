# Development Notes

My more-detailed notes on certain design decisions that I made for the components in this codebase.

## Why Is `this.#value` Used in the `ComboboxField.#handleSearch` `beforeinput` Method?

One very important comment that we made in the `ComboboxField` code was that if the component's value was being set internally, it should use `set ComboboxField.value()`, **_not_** `ComboboxField.#value`. The only exception to this rule is when the `combobox`'s value needs to be set to `null`, as we don't want the `setter` to support `null`. Setting the `combobox` value to `null` is only for edge cases where the `combobox` needs to declare itself as unitialized (e.g., because it currently has no `option`s). Besides that, the `setter` should always be used.

Despite what the "rule" for `ComboboxField.#value` is, the private field &mdash; which represents the component's internal value &mdash; is directly being used intentionally in the `ComboboxField.#handleSearch` method (used for `beforeinput` events). This is another rare exception for using the private field directly.

The reason for this additional exception is simple: Using `set ComboboxField.value()` could lead to unexpected behavior in the event handler when the `combobox`'s filter mode is `clearable` or `anyvalue`. Imagine if the `combobox` had a `<combobox-option value="">Choose</combobox-option>`. In this scenario, if `set ComboboxField.value()` was used, the code would end up trying to select the "Empty String Option" whenever the user tries to clear their filter &mdash; causing the filter to get reset to `Choose`. This means that users would never be able to clear a `clearable` (or `anyvalue`) `combobox`. That's a poor and unacceptable UX.

There are perhaps other edge cases to be concerned about as well when it comes to the `beforeinput` event handler. But we don't have to think about _any_ of those concerns if we make all such concerns _impossible_ by always A&rpar; setting the internal `ComboboxField.#value` directly and B&rpar; deselecting the previously-selected `option`.

## Why Doesn't `Tab`bing Select the Active `option` in the `combobox`? (2025-05-25)

Some of you may be wondering why I'm even addressing this question, as the idea of selecting an `option` when the user `Tab`s _away_ from the `combobox` might sound preposterous. Indeed, it is preposterous. But WAI-ARIA's examples for `combobox`es, such as their [Select-Only Combobox Example](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/), uses `Tab` as a means to choose `option`s. Since WAI-ARIA is an excellent frame of reference for all things related to accessibility, we initially decided to adopt their behavior. However, we've since decided to reject said behavior instead.

Our reasoning for choosing _not_ to select the `option` which is the `aria-activedescendant` of the `combobox` on `Tab` is quite simple: **_The user experience is unintuitive and inconvenient_**. Regarding intuition, people who `Tab` _away_ from a form control typically expect `focus` to move from one element to another _without_ causing unexpected side effects. If they see `option`s getting selected as they tab through a form with our `combobox` component, they might get confused and/or annoyed. Inversely, I've never seen a person who's eager to choose an `option` in a `combobox` via `Tab`bing -- nor have I ever desired such a "feature" myself. Not even the native `<select>` element exhibits this behavior (at least as of today).

The inconvenience concern might be even greater than the intuition concern, though. Imagine a user who chooses an `option` in a `combobox`. Perhaps at some later point, they choose to revisit the `combobox` to see if there is any other `option` that they would prefer more. So they use the Arrow Keys to navigate through the list, and they ultimately decided that their original selection was the best one. In that case, they may choose to `Tab` _away_ from the `combobox` while an _unselected_ `option` is the `aria-activedescendant`. With WAI-ARIA's behavior, this would cause them to choose a value that they _did not_ want, and they'd have to go back and re-select their original choice. Additionally, from this point on, they'll have to remember to do an extra key stroke (e.g., `Escape`) whenever they're done searching through a `combobox` and they want to `Tab` to another form control without selecting the currently-active `option`. This is frankly an unnecessary pain.

It's worth noting that the [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/datalist) element seems to select the highlighted suggestion when the user presses the `Tab` key (in addition to moving `focus`). This _might_ be part of WAI-ARIA's motivation for expressing this behavior as well. But there are three things worth noting here:

1. **This behavior is inconsistent across browsers**: In Chrome 135 and Firefox 137 on MacOS 15.4, `Tab`bing away from a text-based `<input>` with a highlighted `<datalist>` suggestion will cause the suggestion to become the `<input>`'s value. However, this behavior is not seen in Safari 18.4 on the same Operating System.
2. **This behavior is inconsistent across form controls**: The behavior described for text-based `<input>`s in Chrome 135 _is not_ experienced with non-text-based `<input>`s like `<input type="color">` and `<input type="date">`. Suggestions will still appear, and they can still be highlighted, but they won't be selected when the user hits the `Tab` key. (Firefox 137's UX is even more odd, because it seems they don't even support `<datalist>` for some `<input>`s.)
3. **The user experience with a `combobox` is a _separate_ experience**: Because of how browsers style the native `<datalist>` element, users may be primed to expect certain behavior as they `Tab` away from the highlighted suggestion. However, it's highly unlikely that users would expect the exact same behavior from a custom-styled `combobox` component. (We certainly haven't expected that behavior.) And the behavior of the vast majority of `combobox`es which we've experienced on the internet further prime us _not_ to expect an `option` to be selected when `Tab` is pressed.

Consequently, the behavior of the `<datalist>` element is not sufficient justification for selecting an `option` during `Tab`bing. Moreover, many popular `combobox` components _do not_ select an `option` when `Tab` is pressed. This includes `Reach UI`, `Material UI`, `Vue Select`, `Mantine`, and `Shadcn UI`. (Oddly enough, `React Select` chooses `option`s during `Tab`bing.) If most of the `combobox`es seen in highly-favored UI Libraries don't select an `option` when `Tab` is pressed, this implies that most users will expect that behavior _not_ to be present in other `comboboxes` which they encounter. (Yes, there may be other variations between the `combobox`es on the internet, but many of these variations are minor for most users -- at least when it comes to the _good_ `combobox`es. Overall consistency on the internet is to be desired whenever possible.)

It feels ridiculous to have to write a defense for _not_ selecting `option`s while `Tab`bing, but we feel the need to address this because of WAI-ARIA's `combobox` examples.

## Why Doesn't the `ComboboxField` Expand When `focus`ed? (2025-05-23)

In all of our previous iterations of _filterable_ `combobox` components, we designed the `combobox` to reveal its `listbox` immediately after being focused. (This design decision was likely influenced by libraries like `React Select` and `Vue Select`, which exhibit this behavior. **EDIT**: React Select no longer exhibits this behavior. Was it changed?) This approach mainly benefits Visual Users: When someone `Tab`s to a `combobox` field, they'll be met _immediately_ with a list of `option`s (in the `listbox` popup) and a blinking `cursor` (in the `combobox` element). This makes it clear-as-day that the user can click one of the available `option`s _or_ use the keyboard to filter down into the list. Given the UI, the user will likely know that they can hit `Enter` to select an `option` as well.

Although this experience is great for Visual Users, it's bad (and irreparably so) for Screen Reader Users. If a Screen Reader User focuses the `combobox` component that we described earlier, then they'll be met with a `listbox` popup before they're told that they're on a `combobox`. (This is because the appearance of the `listbox` interrupts/overrides the announcement of the `combobox` that was just focused.) Such users likely won't know what triggered the `listbox` _popup_ to appear (remember, we're using `aria-haspopup`), and they probably won't know that they can filter the available list of `option`s either. In fact, they may not know what _any_ of the consequences would be for pressing a given key on their keyboard. Basically, the user will be at a loss upon encountering our `combobox` -- at least initially. Thankfully, in some cases, the Screen Reader _might_ announce that the user is on a `combobox` after the `listbox` is announced, but this behavior is inconsistent across browsers on MacOS with VoiceOver. And who knows what inconistencies or ambiguities could arise with other tools?

Naturally, the alternative here is to _avoid_ expanding the `combobox` when it is focused. That way, Screen Reader Users would understand that they're on a `combobox` when they visit the form field, and they could set their expectations accordingly. Unfortunately, this would mean that Visual Users might not know that the `combobox` is a "Filterable Dropdown Form Control" when they focus it ... or would it?

You see, advantage of being a Visual User is that it's possible to gain full context by looking at a page. If the `combobox` field shows a Caret Icon which rotates based on whether the `combobox` is expanded or not, this could be a clear indication that the `combobox` is a "Dropdown" with a list of `option`s. And if the `combobox` shows a cursor to the User when they focus the form control, that will likely indicate that this "Dropdown" is searchable. Keyboard Users should be able to deduce that they can open the `combobox` by pressing an Arrow Key or typing into the searchbox. As for Mouse Users, we can simply expand the `combobox` when it's clicked (just like we do when the element is unfilterable).

The only perceivable drawback of this approach for Visual _Keyboard_ Users is that there's a possibility they won't see _all_ of the `option`s the first time that they expand the `combobox`. If they expand the `combobox` by pressing an Arrow Key, then they'll see all of the `option`s immediately and should be able to conclude from there that they're working with a "Filterable Dropdown". If they expand the `combobox` by providing a filter, then they may not know/see all of the available `option`s initially. However, it should be (sufficiently) obvious that deleting the filter will expose all of the `option`s. After that first encounter, the Visual Keyboard User's expectations will be properly set.

Is this a safe bet? Other libraries seem to think so. [Reach UI](https://reach.tech/combobox/), [WAI-ARIA](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-list), and [Material UI](https://mui.com/material-ui/react-autocomplete/) (all of which seem to take Accessibility more seriously than React Select and Vue Select) are libraries that _don't_ expand their `combobox`es on `focus`. [Shadcn UI](https://ui.shadcn.com/docs/components/combobox) is the same way, but its approach to handling `combobox` expansion seems a little unorthodox (and potentially confusing). Many of the components from these tools are (or have been) widely used (or used as frames of reference for building other components), so the Visual User Experience should be just fine for Mouse Users and Keyboard Users alike.

Finally, if developers _really_ want their `combobox`es to expand on `focus`, then they can easily provide that logic themselves with a simple `focus` handler:

```js
function handleFocus(event) {
  const combobox = event.currentTarget;
  combobox.setAttribute("aria-expanded", String(true));
}
```

With these considerations, we think it best to deviate from React/Vue Select to provide a better experience for users overall. This means we'll no longer be expanding the `ComboboxField` on `focus`.

## What's the Motivation behind Using `static` Methods as Event Handlers? (2025-05-12)

As as rule, we prefer using `static` event handlers in our Web Components whenever possible. The reason for this is quite simple: If you have a single function that _every_ instance of your component uses, then you'll save _significantly_ on memory usage. For example: If 100 `SelectEnhancer` components are rendered to the DOM, only _one_ `#handleDelegatedOptionClick` "function" (`static` method) will be created. This function will be referenced by all of the corresponding event listeners registered for the `SelectEnhancer`.

By contrast, consider the `ComboboxField.#handleTypeahead` function: It is an arrow function that is uniquely created and assigned _every time the component is instantiated_. Thus, if we create 100 `ComboboxField`s, we'll have 100 `#handleTypeahead`s -- one for each instance of the component (even though they do virtually the same thing). This is far less performant when it comes to memory. Why use arrow functions in that case? Because sometimes we need access to `this` inside event handlers.

Now, you might think that it would be better to use a regular method instead of an arrow function to resolve this problem. Doing so would provide access to `this` without creating `N` instances of the same function for each instantiated component. (The method would simply use different values for `this` based on the component instance.) However, when it comes to registering event handlers (`this.addEventListener("click", this.handleClick`), we have to use `this.handler.bind(this)` to preserve a proper reference to `this`. And unfortunately, doing so would cause 100 `handler`s to be created anyway. The approach would technically have _slightly_ better memory usage than arrow functions, but the inconvenience it causes (having to maintain a consistent reference to the bound function between `connectedCallback` and `disconnectedCallback`) isn't really worth it unless memory becomes a greater issue.

So basically, because of memory usage, we prefer `static` methods whenever possible. We make these methods private because they're solely the concern of the owning class/component, and they should not be tampered with.

## Why Loop through **_Every_** `option` during Filtering? (2025-05-06)

It's not great that we have to loop through **_all_** of our `option`s whenever we want to filter them in `filter` mode. However, there isn't really another alternative. We need to meticulously handle the `option`-searching feature in such a way that `option`s are dynamically revealed _or_ hidden as the filter is updated -- **_reliably_**.

"Reliably" is the keyword there. It would be great if we could filter only a subset of our `option`s. For example, if the user already has the string `"ap"` in the searchbox, it would be awesome if we could search _only_ through the `option`s that are _currently_ in the set of revealed `option`s. This would be much faster, but the problem with this idea is that it isn't reliable. For one thing, if the user moves the cursor backwards before adding new characters, then the current set of filtered `option`s is no longer valid and we need to search through all of the `option`s again anyway. (This is because the filter will now be, for example, `"a?p"` instead of `"ap?"`) The various kinds of [`inputType`s](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType) also complicate things. For instance, how would your filtering logic change if someone used `deleteWordBackward`?

At the end of the day, your implementation will be much simpler and much more practical if you loop through the entire set of `option`s whenever the filter is updated. If you really want a Swiss cheese performance gain, use a Trie. (See [Wikipedia](https://en.wikipedia.org/wiki/Trie) and [ThePrimeagen](https://frontendmasters.com/courses/algorithms/tries/).)

### Why Use `data-filtered-out` Instead of Dynamically-creating (or -arranging) DOM-content?

Related to the issue of filtering `option`s, it is important to determine how `option`s are hidden/displayed during filtering. In the past, with React, we kept an internal array of all the `option`s as `{ label: string; value: string }` objects. When the user updated the searchbox with a new filter, we would loop through all of the objects in this array (which is unavoidable, like we mentioned earlier) to determine the `ReactElement`s that should be rendered to the DOM.

Unfortunately, this approach is _very_ wasteful. It effectively means that you are deleting/creating new DOM nodes (and Virtual-DOM objects in React's case) every time the filter changes. But why do that? Isn't it better to _reuse_ the same set of `option` elements and display or hide them as needed?

That's the idea behind our `data-filtered-out` approach. We don't delete/re-create `<combobox-option>` elements when the filter changes. Instead, we create all of the `<combobox-option>`s once and only once. Then, when the filter changes, we toggle a `data-filtered-out` attribute on each of these `option`s, and this attribute (when paired with CSS) determines whether or not the `option` will be displayed to the user. This is much better for the memory-management of our application! No nodes have to be deleted (and garbage collected) or re-created -- ever! And toggling attributes is very cheap. :&rpar;

HOWEVER! There is one noteworthy flaw with this approach (or at least, with our _original_ implementation of it)... Specifically, our `ArrowDown`/`ArrowUp` searching logic takes a hit... If, while we're filtering through `option`s, we're simply _hiding_ `option`s instead of removing them from the DOM/`listbox`, then `Element.nextElementSibling()` will no longer be guaranteed to give us a valid `option`. That is, the method might give us an `option` that has been filtered! So then, we have to enter a loop and keep looking for the next sibling until we find one that _isn't_ filtered out. As the number of matching `option`s decreases, the amount of `option`s that have to be searched through in this loop increases. That means our `ArrowDown`/`ArrowUp` search logic is no longer `O(1)` (a simple `Element.nextElementSibling()` call), but `O(N)` (_looped_ calls to `Element.nextElementSibling()`)!

Now, depending on how the developer using the component orders their `option`s (e.g., if everything is in alphabetical order), this may not be as much of a practical problem. But that isn't a guarantee. Additionally if someone wants to play with the arrow keys at the bounds of the filtered `option`s list, then we can still run into `O(N)` issues where the component keeps searching until `Element.nextElementSibling()` returns `null`.

Enter [WAI-ARIA's solution](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-autocomplete-list/#javascriptandcsssourcecode). We thought it was silly at first, but actually it's quite brilliant and memory-considerate when you think about it. "On mount" (technically, on `construct`ion of their utility, which attaches itself to an already-mounted DOM node), their `ComboboxAutocomplete` class caches all of the `option` elements in an internal array. As the user filters through the existing set of `option`s, the elements in this internal array are `append`ed to the `listbox` element if they match the search criteria. And the `listbox` always has its `children` emptied before performing this search + append logic.

On the surface, this might sound odd, but it isn't. Just like us, they create all of the `option` elements _once and only once_. But unlike us, they dynamically change the content of the `listbox` element as the user filters through the `option`s. Consequently, as the `ArrowUp`/`ArrowDown` keys are pressed, the code only has to do `Element.nextElementSibling()` (and the like). This keeps the logic for `ArrowDown`/`Home`/etc. at O(1). (Note that WAI-ARIA doesn't actually seem to leverage methods like `Element.nextElementSibling()`, but they _could_ if they wanted. That's what's important.)

Although the `listbox` has its children reset on each change to the filter with this implementation, there are fewer memory concerns here. The _references_ to the nodes themselves remain in the internal array, and these elements are never destroyed or recreated. Thus, the only thing that changes on a per-filter basis is the Tree Relationship between all of these nodes. (You can probably argue that there's a performance cost to continuously establishing and disassembling these relationships, but that cost will be much smaller than that of creating and deleting new DOM nodes continuously.)

So... WAI-ARIA's solution has O(1) performance when it comes to moving fowards or backwards in a filtered `listbox`. And their solution doesn't delete or recreate DOM nodes... Should we switch to their solution? Well, not necessarily.

Literally, while writing this Note, it dawned on me that I could leverage WAI-ARIA's approach in my own way. Instead of creating an internal array for the list of `option`s, I can let `listbox.children` itself be the "cached array". And instead of using `Element.nextElementSibling()` to find the next matching `option` in `filter` mode, I can keep track of an internal `#filteredOptions` array. When we loop through `listbox.children` in the event handler for filtering the `option`s, we can `push` all matching `<combobox-option>`s into the `#filteredOptions` array. This array can then be referenced to find the next (or previous) `option` that matches the current filter when a user presses `ArrowDown`, `ArrowUp`, or the like.

This solution requires keeping track of the `#currentFilterIndex` as the user navigates through the filtered `option`s with the keyboard. So `ArrowUp` would decrement the index, and `End` would set the index to `#filteredOptions.length - 1`. This index would also have to be reset to `0` every time the filter is changed.

This approach is very simple to implement, and it's arguably more performant as well. Why? Because we'll not only skip creating/deleting DOM nodes, but we'll also skip establishing/breaking the relationships between those nodes. WAI-ARIA was already tracking 2 separate arrays (`allOptions` and `filteredOptions`) in addition to managing `listbox`'s children; so this should be faster. The only downside with our implementation is that we have to keep track of `#currentFilterIndex`, but that shouldn't have any significant impacts on performance or memory, and in the end the `data-filtered-out` approach should still come out faster.

#### What about `Trie`s?

Bringing a `Trie` into the mix would complicate the `data-filtered-out` approach because the data structure caching the `option`s would no longer be an array. If we were adding/removing nodes from the DOM (_without_ recreating them), then we could recursively search a `Trie` for all matching `option`s and then append them to the `listbox`. Unfortunately, this means that the `listbox` would need to have its children replaced on every filter update. Not only is that a potential performance hit, but it conflicts with our current approach of (conditionally) modifying the `combobox`'s value as new `option`s are added to (or removed from) the owned `listbox`. (At least, the conflict exists at the time of this writing.)

However, there might be a workaround that is still compatible with our current approach, and that allows us to leverage `data-*` attributes to get the job done: You could have all `option`s hidden by default. Then, as the user searches, you could do a breadth (or depth) first search to get all of the `option`s that should be _filtered in_. (In that case, we'd probably have something like a `data-matching` attribute -- instead of a `data-filtered-out` attribute -- to reveal these `option`s.)

These `option`s wouldn't need to be created or destroyed, and they wouldn't need to be moved in-or-out of the `listbox`. They could be left within the `listbox`, and the `Trie` data structure could simply reference those DOM nodes. (The existence of a DOM node on a `Trie` node could be used instead of an `isWord` property to verify that a given path in the `Trie` represents a valid `option`.) As the `Trie` is being searched, it can push valid `option`s into an array of `#filteredOption`s. When the search through the `Trie` completes, the `option`s in this array could all be toggled "on" with a `data-matching` attribute (or the like). As with before, a `#currentFilterIndex` would still be required here to allow for navigation with `ArrowUp`/`ArrowDown`/etc.

When the user changes the filter (or when the user leaves the `combobox`), all of the `option`s in `#filteredOption`s would need to have their `data-matching` attributes removed. And `#filteredOptions` would need to be emptied before the `Trie` traversal that re-populates the array starts.

When the user empties the filter (and optionally, when they leave the `combobox`), all `option`s would need to have their `data-matching` attributes removed. Since the performance would already be `O(N)` for the `Trie` in this scenario (`N` being the number of `option`s), it's probably fine to leverage `Element.nextElementSibling()` for that (unless the performance of `Trie` traversal is somehow faster than the performance of `DOM` traversal). Of course, if performance was really a concern, you could simply refuse to display any `option`s until _after_ the user starts searching.

The performance resulting from this approach would probably be better than our current implementation, but we'd need to do some measurements to verify that. This solution would require slightly more effort, but not too much. Most of the complexity would be around managing the `#filteredOptions` array properly and emptying/updating it at the right times. But even if this doesn't introduce too much complexity, it's still added complexity. And another cost to consider is that implementing a `Trie` that's used in the `combobox` would increase the bundle size of the component. So although this solution might be effective and performant, it probably isn't worth addressing unless someone using the component is working with an enormous amount of `option`s and needs such performance gains.

Notice that we're intentionally avoiding things like `querySelectorAll` here, because that would require visiting every single node and would thus be vastly less performant.

## Pros and Cons of Allowing `ComboboxOption.attributeChangedCallback()` to Run When Its Owning `combobox` Is Present Instead of When It `isConnected`

Originally, the `ComboboxOption`'s `attributeChangedCallback()` was only allowed to run after the component was mounted. However, we thought it might be a good idea to relax the constraints by allowing the callback to run if the owning `combobox` existed (which -- based on how the `ComboboxOption` class is written -- implies that the owning `listbox` also exists). In the end, we found that there were pros and cons to this approach (at least with respect to our current implementation of the component). Below are the pros/cons we discovered, and the final decision that we made.

### Cons

1. There are performance concerns if the `selected` attribute is supplied to multiple `combobox-option`s on mount. (This is unrealistic and technically not allowed in the `<select>` spec anyway -- at least for its single-select variant). There are also performance concerns if the `value` attribute is on every `combobox-option` on mount. (By contrast, this is very realistic, for example, with a U.S. State selector with `value`s that corresponds to IDs on the backend). Changing these attributes can trigger the owning `ComboboxField`'s value update logic. (Can we evaluate how much of a concern the value selection logic is?)
2. We still won't be able to support the case of newly-added `option`s causing `combobox` value updates (like the `<select>` element) because the related `MutationObserver` is only setup after the `ComboboxField` is mounted to the DOM. (I don't think there's a safe way to handle this that doesn't egregiously leak implementation details?)

### Pros

1. Could it maybe help with setup/mounting logic if people don't care about progressive enhancement and they just want to have a DOM that uses a `combobx-container` + `combobox-field` + `combobox-option` directly?
2. In general, obviously this will add more flexibility for DOM manipulation pre-mounting.

### Additional Thoughts

Currently, the `ComboboxOption.attributeChangedCallback()` will only run if the `ComboboxOption` `isConnected` to the DOM (implying that the rest of the "Combobox Unit" is already connected to the DOM as well). Theoretically, we could allow the callback to run at any time as long as its owning `combobox` exists. This would _slightly_ improve the component's flexibility as well as the process of setting up the entire "Combobox Unit" as a whole. Particularly, it would simplify the process of setting the `ComboboxField`'s default value when the "whole unit" is mounted (i.e., during the container/adapter component's `connectedCallback`), and it would enable to the `ComboboxField`'s value to updated as its **_currently-owned_** `ComboboxOption`s have their `selected` properties changed. However, the gains acquired here are likely negligible. Here's why:

#### 1&rpar; Mounting Logic Will Always Be Needed

First of all, the entire "Combobox Unit" will always require an "Adapter/Container Component" which sets up the proper a11y relationships between the various parts of the Combobox. (The container component might even perform additional logic as well, such as transferring attributes or removing unsupported children.) Since the logic for calculating a `ComboboxField`'s "default value" onMount (i.e., during the container's `connectedCallback`) is simple, why not let developers write the logic themselves in the same place where the a11y setup logic written?

On that note, the real goal that we're trying to achieve here is feature-parity with the native `<select>` element. "If a `<select>` element that A&rpar; isn't connected to the DOM and B&rpar; has pre-existing `<option>`s has a new `defaultSelected` option added to it, why can't our Combobox Component?" That's the idea. However, perfect feature parity with the `<select>` element in this regard is impossible.

For this to work, our `ComboboxField` would have to start observing the children of its `listbox` immediately after it's created. But the `ComboboxField` doesn't know the context in which it was created, and so it doesn't know for certain whether the `listbox` that it's supposed to own exists yet. The only component that has said information is the Adapter/Container Component that's setting everything up. But again, that brings us back to putting everything in the developers' hands when they build their own Adapter/Container components.

Allowing the `ComboboxOption.attributeChangedCallback()` to run as long as an owning `combobox` exists gets us a _tiny_ step closer to feature parity with the `<select>` element. In particular, if `ComboboxOption`s which are _already associated_ with a `ComboboxField` have their `selected` properties updated _without the whole "Combobox Unit" being connected to the DOM_, then we would still be able to support value updates in said scenario. But again, who is practically going to be updating `ComboboxOption` values/states in some random `DocumentFragment` that exists outside of an Adapter/Container component?

The ultimate question arising here is this: What _practical_, _noticeable_ value is being provided to people by enabling `ComboboxOption.attributeChangedCallback` to run even if it isn't connected to the DOM?

#### 2&rpar; JS Frameworks Might Break Expectations

When it comes to JavaScript frameworks, we don't have immediate insight into how various frameworks operate. For example, if React creates elements, attaches them to their parents, _and then_ modifies their attributes (based on the supplied JSX props), then our update to the `ComboboxOptoin.attributeChangedCallback()` would allow the `ComboboxField`'s value can be initialized correctly in the event that people want to use all 3 parts of the "Combobox Unit" (`Field`, `Option`, and `Container`/`Adapater`) directly instead of relying on a `<select>` element. **_However_**, if React creates elements, modifies their attributes, _and then_ attaches them to their parents, then there's a chance that all of the value initialization will not be augmented by the `ComboboxOption.attributeChangedCallback()` (because the `option` won't have an owning `combobox` until _after_ it's attached to its parent `listbox`). In that case, `ComboboxOption.attributeChangedCallback()` has provided minimal value to _some_ developers (e.g., a fraction of all the pure-JS devs), but it has also _slowed_ the mounting/intialization process for _all_ developers (regardless of whether or not they use JS frameworks). 👎🏾

### Conclusion

There's probably more that could be said here, but these are the considerations that led to our decision _not_ to refactor `ComboboxOption.attributeChangedCallback()` so that it no longer had to wait until it was connected to the DOM. We just don't see any practical benefits to such a refactor, and there is performance cost to said refactor (even if the cost is minimal). If this **_really_** seems to be a big need in the future, we can revisit this decision.
