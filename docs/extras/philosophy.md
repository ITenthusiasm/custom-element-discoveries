# Philosophy

Here you'll find some of my philosophies for building Web Components. It's always helpful to understand what was going on in a library maintainer's mind when they decided to enable (or restrict) what users of their library could do. I myself need some reminders about what the overarching goals of my Web Components should be, so I've decided to document a few "philosophies" here. This will not be exhaustive or complete anytime soon. It's just a place for me to dump thoughts on conclusions that I've already (or mostly) made.

## You Don't Have to Do/Implement Everything

When building and designing components for consumption by developers, you don't need to do/implement everything; you just need to do enough to _enable_ everyone (or a sufficiently large userbase) to accomplish what they want. If there are [non-essential] things that can be done in userland, it's probably best to let such things be done there instead of implementing the behavior yourself. After all, supplying too many of your own "features" runs the risk of 1&rpar; overwhelming consumers with excessively large options or configurations, 2&rpar; unnecessarily **bloating the bundle size** of the package for **everyone**, and 3&rpar; introducing **unerasable, undesirable behavior** for a subset of users.

Consider the core HTML elements, HTML attributes, and ARIA attributes. Generally speaking, they are very powerful. However, because these elements and attributes are simple, they are also highly flexible and composable. For example: `<input>`s are generally excellent `textbox` components. If functionality needs to be added -- such as automatically updating a user's input to match a certain pattern -- that functionality can easily be added via JavaScript. Since `<input>`s don't try to perform any value masking, developers don't have to worry about encountering interference with the JS logic that they write. At the same time, developers are _empowered_ by the `<input>`s core functionality to add masking logic with _a fair amount of ease_.

Now yes, there are certainly important features that are _missing_ from the core elements and attributes. But it is far better for developers to have fewer features that can be _composed_ to meet _all_ needs. After all, userland features can always be abstracted into functions, Custom Elements, or JS Framework Components. The [much worse] alternative is for developers to have _rigid_ components that can do quite a lot, but which still can't be _composed_ to meet all needs or be _reduced_ to remove undesired behavior. In such a scenario, no amount of custom JS will ever save them. Getting the picture?

The reality is, you can have a lot of ideas about what users _might_ want to do, but oftentimes you just don't know. You _must_ avoid burning hours on "features" that most users aren't interested in. (In fact, even if users are interested in certain features, they still might not truly be needed or useful.) If you feel there's a niche feature that you _must_ satisfy, then instead of implementing the feature, try to design your component(s) in such a way that others can easily implement the feature on their own. This way, people who don't want the feature won't have to worry about including undesired behavior in their app, and people who do want the feature will be able to include it in their app with ease. (Going back to the example with `<input>`s, the `beforeinput` and `input` events are more than enough to satify developers' masking needs _with ease_.)

(As I write this, I'm getting memories of the philosophy notes that I wrote for the [`FormObserver`](https://github.com/enthusiastic-js/form-observer/blob/main/docs/extras/philosophy.md). I guess my brain just thinks a certain way.)

**Here's an example: Selecting the `option` which is the `aria-activedescendant` in a `combobox` when the `Tab` key is pressed.** WAI-ARIA's guides do this in their [Combobox Examples](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only), despite the fact that this is contrary to the native `<select>`'s behavior. Should we add this feature to our `<combobox-field>` too? Well, if we did, some developers might not want that behavior. Then what would they do? They can't stop the `<combobox-field>` from registering the `keydown` event handler related to the `Tab`bing behavior. So if we wanted to help developers disable this behavior, we'd need to expose a new custom attribute/property on the component.

But why go through all the trouble of doing that when developers can add a simple 2-line `keydown` event handler that handles the `Tab`bing logic for them? Even more: They could wrap this behavior in a reusable component that creates and registers said event handler. (The reusable component can be a child Custom Element, or a JS Framework Component which wraps our component.) This is a **_tiny_** lift for devs, and doing things this way helps us avoid: 1&rpar; bloating the bundle size for all developers, and 2&rpar; overwhelming developers with more options/attributes/properties than they asked for.

A similar thing could be said for [Material UI's autocomplete feature](https://mui.com/material-ui/api/autocomplete/#autocomplete-prop-autoSelect). Sure, some developers might want to autoselect an `option` on `blur`, but others might want autoselection to occur on `input` instead. Still, some may never want to see autoselection behavior at all. Again, one option for us is to implement this logic ourselves and give developers configuration attributes/properties. But a better approach is to communicate to developers whenever an `option` _can_ be autoselected, and to give them _easy access_ to said autoselectable `option`. This way, developers again have the opportunity to perform autoselection logic on `blur` _or_ on `input` _or_ whenever else -- all by registering another tiny event handler of their own.

Getting the idea? We want to maximize the flexibility and robustness of the component, thus enabling all devs to do whatever they want with _ease_ and _a tiny bundle size_. However, we want to _avoid_ implementing every feature imaginable, as this would require us to place a lot of functionality behind enable/disable properties/attributes. Oftentimes, there will be a much better alternative to such madness.
